diff -Naru ruby18.orig/eval.c ruby18/eval.c
--- ruby18.orig/eval.c	2009-09-04 23:20:38.000000000 +0900
+++ ruby18/eval.c	2009-09-22 13:44:50.000000000 +0900
@@ -8277,6 +8277,13 @@
     }
 }
 
+struct RNode 
+*rb_get_node_from_block(data)
+    void *data;
+{
+    return ((struct BLOCK*)data)->frame.node;
+}
+
 void
 Init_eval()
 {
diff -Naru ruby18.orig/gc.c ruby18/gc.c
--- ruby18.orig/gc.c	2009-09-04 23:20:38.000000000 +0900
+++ ruby18/gc.c	2009-10-04 23:05:10.000000000 +0900
@@ -44,6 +44,8 @@
 #include <windows.h>
 #endif
 
+#include "time.h"
+
 void re_free_registers _((struct re_registers*));
 void rb_io_fptr_finalize _((struct rb_io_t*));
 
@@ -314,7 +316,7 @@
     }
 }
 
-#undef GC_DEBUG
+#define GC_DEBUG
 
 void
 rb_global_variable(var)
@@ -353,6 +355,7 @@
 #ifdef GC_DEBUG
     char *file;
     int   line;
+    time_t time;
 #endif
 } RVALUE;
 
@@ -458,6 +461,7 @@
 #ifdef GC_DEBUG
     RANY(obj)->file = ruby_sourcefile;
     RANY(obj)->line = ruby_sourceline;
+    RANY(obj)->time = time(NULL);
 #endif
     return obj;
 }
@@ -2147,6 +2151,210 @@
     return (VALUE)((long)obj|FIXNUM_FLAG);
 }
 
+/* heap monitor start */
+#include "rubyio.h"
+
+static FILE *heap_dump = NULL;
+
+#define P_REFOBJ(V) do { \
+    register void *v = (void*)V; \
+    if (is_pointer_to_heap(v)) \
+        fprintf(heap_dump, "    0x%08X\n", (unsigned int)rb_obj_id((VALUE)v)); \
+} while (0)
+
+static int
+print_obj_unit(key, value, lev)
+    VALUE key, value;
+    int lev;
+{
+    P_REFOBJ(value);
+    return ST_CONTINUE;
+}
+
+static void
+print_obj_set(tbl)
+    st_table *tbl;
+{
+    if (!tbl) return;
+    st_foreach(tbl, print_obj_unit, 0);
+}
+
+extern struct RNode* rb_get_node_from_block(void *data);
+
+static void
+os_print_obj(argc, argv, os)
+    int argc;
+    VALUE *argv;
+    VALUE os;
+{
+    int i;
+    VALUE file;
+
+    rb_scan_args(argc, argv, "10", &file);
+    if (BUILTIN_TYPE(file) != T_FILE) {
+        rb_raise(rb_eArgError, "wrong type argument %s (should be file object)",
+                rb_obj_classname(file));
+    }
+
+    rb_gc_start();
+
+    heap_dump = GetWriteFile(RFILE(file)->fptr);
+
+    for (i = 0; i < heaps_used; i++) {
+        register RVALUE *p, *pend;
+
+        p = heaps[i].slot; pend = p + heaps[i].limit;
+        for (;p < pend; p++) {
+            register VALUE obj = (VALUE)p;
+            register int type = p->as.basic.flags & T_MASK;
+
+            if (type == T_NONE || 
+#ifdef T_ZOMBIE
+                type == T_ZOMBIE || 
+#endif
+                RANY(obj)->file == NULL ||
+                strcmp(RANY(obj)->file, "(null)") == 0) continue;
+
+#ifndef RSTRING_PTR
+#define RSTRING_PTR(s) (RSTRING(s)->ptr)
+#endif
+#define P_BAR()      fprintf(heap_dump, "==========================================\n")
+#define P_REFTITLE() fprintf(heap_dump, "referring_to:\n")
+#define P_OBJID()    fprintf(heap_dump, "object_id: 0x%08X\n", (unsigned int)rb_obj_id(obj))
+#define P_TYPE(T)    fprintf(heap_dump, "type:      %s\n", T)
+#define P_CLASS()    fprintf(heap_dump, "class:     %s\n", rb_obj_classname(obj))
+#define P_INSPECT()  fprintf(heap_dump, "inspect:   %s\n", RSTRING_PTR(rb_obj_as_string(rb_inspect(obj))))
+#ifdef GC_DEBUG 
+#define P_SOURCE() do { \
+    struct tm *tmp; \
+    char strtime[64]; \
+    fprintf(heap_dump, "filename:  %s\n", RANY(obj)->file); \
+    fprintf(heap_dump, "linenum:   %d\n", RANY(obj)->line); \
+    tmp = localtime(&RANY(obj)->time); \
+    if (tmp && strftime(strtime, sizeof(strtime), "%F %T", tmp)) { \
+        fprintf(heap_dump, "time:      %s\n", strtime); \
+    } \
+} while (0)
+#else
+#define P_SOURCE() ()
+#endif 
+            switch (type) {
+/*
+            case T_NODE:
+#define P_NODE(NDTYPE, ND) do { \
+    P_BAR(); \
+    P_SOURCE(); \
+    P_TYPE("Node"); \
+    P_OBJID(); \
+    fprintf(heap_dump, "nodetype:  0x%02X\n", NDTYPE); \
+    P_REFTITLE(); \
+    P_REFOBJ(ND.u1.node); \
+    P_REFOBJ(ND.u2.node); \
+    P_REFOBJ(ND.u3.node); \
+} while (0)
+                P_NODE(nd_type(obj), p->as.node);
+                break;
+*/
+            case T_CLASS:
+            case T_ICLASS:
+            case T_MODULE:
+            case T_OBJECT:
+            case T_FLOAT:
+            case T_STRING:
+            case T_REGEXP:
+            case T_ARRAY:
+            case T_HASH:
+            case T_STRUCT:
+            case T_BIGNUM:
+            case T_FILE:
+            case T_MATCH:
+            case T_VARMAP:
+                P_BAR();
+                P_SOURCE();
+                P_CLASS();
+                P_OBJID();
+                if (type != T_ICLASS && type != T_VARMAP &&
+                    strcmp(rb_obj_classname(obj), "Object") != 0) {
+                    P_INSPECT();
+                }
+                if (type == T_CLASS || type == T_ICLASS || type == T_MODULE) {
+                    P_REFTITLE();
+                    print_obj_set(p->as.klass.iv_tbl);
+                }
+                if (type == T_OBJECT) {
+                    P_REFTITLE();
+                    print_obj_set(p->as.object.iv_tbl);
+                }
+                if (type == T_ARRAY) {
+                    long i, len = p->as.array.len;
+                    VALUE *ptr = p->as.array.ptr;
+
+                    P_REFTITLE();
+                    for (i = 0; i < len; i++) {
+                        P_REFOBJ(*ptr++);
+                    }
+                }
+                if (type == T_HASH) {
+                    P_REFTITLE();
+                    print_obj_set(p->as.hash.tbl);
+                }
+                if (type == T_STRUCT) {
+                    long i, len = p->as.rstruct.len;
+                    VALUE *ptr = p->as.rstruct.ptr;
+
+                    P_REFTITLE();
+                    for (i = 0; i < len; i++) {
+                        P_REFOBJ(*ptr++);
+                    }
+                }
+                if (type == T_MATCH) {
+                    P_REFTITLE();
+                    P_REFOBJ(p->as.match.str);
+                }
+                if (type == T_VARMAP) {
+                    struct RVarmap *var = &p->as.varmap;
+
+                    P_REFTITLE();
+                    while (var) {
+                        P_REFOBJ(var->val);
+                        var = var->next;
+                    };
+                }
+                break;
+            case T_DATA:
+                {
+                    P_BAR();
+                    P_SOURCE();
+                    P_CLASS();
+                    P_OBJID();
+                    P_REFTITLE();
+                    fprintf(heap_dump, "    (the following node)\n");
+                }
+                break;
+            case T_SCOPE:
+                P_BAR();
+                P_SOURCE();
+                P_TYPE("Scope");
+                P_OBJID();
+                if (p->as.scope.local_tbl) {
+                    int n = p->as.scope.local_tbl[0] + 1;
+                    VALUE *vars = &p->as.scope.local_vars[-1];
+
+                    P_REFTITLE();
+                    while (n--) {
+                        P_REFOBJ(*vars++);
+                    };
+                }
+                break;
+            default:
+                break;
+            }
+        }
+    }
+}
+/* heap monitor end */
+
+
 /*
  *  The <code>GC</code> module provides an interface to Ruby's mark and
  *  sweep garbage collection mechanism. Some of the underlying methods
@@ -2179,6 +2387,8 @@
 
     rb_define_module_function(rb_mObSpace, "_id2ref", id2ref, 1);
 
+    rb_define_module_function(rb_mObSpace, "print_object", os_print_obj, -1);
+
     rb_gc_register_address(&rb_mObSpace);
     rb_global_variable(&finalizers);
     rb_gc_unregister_address(&rb_mObSpace);
